import { createClient } from '@/lib/supabase/server'
import { stripe } from '@/lib/stripe'
import { NextResponse } from 'next/server'

// Sync recent bookings from Stripe payment intents
// This is a fallback if webhooks didn't fire
export async function POST(request: Request) {
  try {
    const supabase = await createClient()
    const {
      data: { user },
    } = await supabase.auth.getUser()

    if (!user) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 })
    }

    // Get recent checkout sessions from Stripe (last 24 hours)
    const oneDayAgo = Math.floor((Date.now() - 24 * 60 * 60 * 1000) / 1000)
    const checkoutSessions = await stripe.checkout.sessions.list({
      limit: 50, // Increased limit to catch more sessions
      created: { gte: oneDayAgo },
    })

    console.log(`Found ${checkoutSessions.data.length} checkout sessions to check`)
    console.log(`Looking for user_id: ${user.id}`)

    let syncedCount = 0
    const errors: string[] = []

    // Check each checkout session
    for (const session of checkoutSessions.data) {
      // Only process completed sessions
      if (session.payment_status !== 'paid' || session.status !== 'complete') continue

      // Get payment intent ID from session
      const paymentIntentId = session.payment_intent as string
      if (!paymentIntentId) continue

      // Check if booking already exists
      const { data: existingBooking } = await supabase
        .from('bookings')
        .select('id')
        .eq('payment_intent_id', paymentIntentId)
        .single()

      if (existingBooking) continue

      // Check if metadata matches this user
      const metadata = session.metadata
      if (!metadata || !metadata.activity_id || !metadata.number_of_spots || !metadata.user_id) {
        errors.push(`Session ${session.id}: Missing metadata`)
        continue
      }

      if (metadata.user_id !== user.id) {
        // Skip sessions for other users
        continue
      }

      console.log(`Processing session ${session.id} for user ${user.id}`)

      const activityId = metadata.activity_id
      const numberOfSpots = parseInt(metadata.number_of_spots)

      // Get activity details
      const { data: activity, error: activityError } = await supabase
        .from('activities')
        .select('*')
        .eq('id', activityId)
        .single()

      if (activityError || !activity) {
        errors.push(`Activity ${activityId} not found`)
        continue
      }

      const providerId = activity.provider_id

      // Create booking (QR code will be auto-generated by database trigger)
      const { data: booking, error: bookingError } = await supabase
        .from('bookings')
        .insert({
          user_id: user.id,
          activity_id: activityId,
          provider_id: providerId,
          number_of_spots: numberOfSpots,
          total_price: activity.discount_price * numberOfSpots,
          price_per_spot: activity.discount_price,
          payment_status: 'paid',
          payment_intent_id: paymentIntentId,
          status: 'confirmed',
        })
        .select()
        .single()

      if (bookingError) {
        console.error('Error creating booking:', bookingError)
        errors.push(`Failed to create booking: ${bookingError.message}`)
      } else {
        syncedCount++
        
        // Update available spots
        await supabase
          .from('activities')
          .update({ 
            available_spots: activity.available_spots - numberOfSpots,
            ...(activity.available_spots - numberOfSpots === 0 ? { status: 'sold_out' } : {})
          })
          .eq('id', activityId)

        // Send confirmation emails (don't wait for them to complete)
        if (booking?.id) {
          // Send customer confirmation email
          fetch(`${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:6060'}/api/bookings/send-confirmation`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ bookingId: booking.id }),
          }).catch((emailError) => {
            console.error('Error sending customer confirmation email:', emailError)
            // Don't fail the sync if email fails
          })

          // Send partner confirmation email
          fetch(`${process.env.NEXT_PUBLIC_APP_URL || 'http://localhost:6060'}/api/bookings/send-partner-confirmation`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ bookingId: booking.id }),
          }).catch((emailError) => {
            console.error('Error sending partner confirmation email:', emailError)
            // Don't fail the sync if email fails
          })
        }
      }
    }

    return NextResponse.json({ 
      synced: syncedCount > 0,
      count: syncedCount,
      errors: errors.length > 0 ? errors : undefined
    })
  } catch (error: any) {
    console.error('Error syncing recent bookings:', error)
    return NextResponse.json({ 
      error: error.message || 'Failed to sync bookings',
      synced: false
    }, { status: 500 })
  }
}

